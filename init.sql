-- MySQL dump 10.13  Distrib 8.0.43, for Win64 (x86_64)
--
-- Host: localhost    Database: nextjs_db
-- ------------------------------------------------------
-- Server version	8.0.44

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `articles`
--

DROP TABLE IF EXISTS `articles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `articles` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(200) NOT NULL,
  `slug` varchar(200) NOT NULL,
  `article` text NOT NULL,
  `quiz` json NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `slug_UNIQUE` (`slug`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `articles`
--

LOCK TABLES `articles` WRITE;
/*!40000 ALTER TABLE `articles` DISABLE KEYS */;
INSERT INTO `articles` VALUES (1,'DFS','dfs','<p class=\"article-paragraph\">\n    In the DFS (depth-first search) algorithm, we search the graph by visiting successive neighbouring vertices. When we visit a new vertex, we first check all the places that can be reached from it before returning to the previous level. Graphs may contain loops, so a single vertex could be visited multiple times. To avoid this, we use a visited array in which we mark the points that have already been visited.\n  </p>\n\n  <p class=\"article-paragraph\">\n    In pseudocode, the DFS algorithm can be written as follows:\n  </p>\n\n  <pre class=\"article-paragraph\">\nvisited = {}\nprocedure DFS(node):\n    visited.add(node)\n    for each neighbour in neighbours(node):\n        if neighbour not in visited:\n            DFS(neighbour)\n  </pre>\n\n  <p class=\"article-paragraph\">\n    And in the visualisation, the above code will be executed as follows\n  </p>\n\n  <div class=\"image-grid\">\n\n    <div style=\"position: relative;\">\n      <img \n           src=\"/images/graph/undirected_graph.jpg\" \n           alt=\"DFS - Undirected Graph  - Step 1\"\n           style=\"width:300px;\"\n      />\n      <span class=\"step-badge\">\n        1\n      </span>\n    </div>\n\n    <div style=\"position: relative;\">\n      <img \n           src=\"/images/graph/dfs-phases/phase1.jpg\" \n           alt=\"DFS - Undirected Graph  - Step 2\"\n           style=\"width:300px;\"\n      />\n      <span class=\"step-badge\">\n        2\n      </span>\n    </div>\n\n    <div style=\"position: relative;\">\n      <img \n           src=\"/images/graph/dfs-phases/phase2.jpg\" \n           alt=\"DFS - Undirected Graph  - Step 3\"\n           style=\"width:300px;\"\n      />\n      <span class=\"step-badge\">\n        3\n      </span>\n    </div>\n\n    <div style=\"position: relative;\">\n      <img \n           src=\"/images/graph/dfs-phases/phase3.jpg\" \n           alt=\"DFS - Undirected Graph  - Step 4\"\n           style=\"width:300px;\"\n      />\n      <span class=\"step-badge\">\n        4\n      </span>\n    </div>\n\n    <div style=\"position: relative;\">\n      <img \n           src=\"/images/graph/dfs-phases/phase4.jpg\" \n           alt=\"DFS - Undirected Graph  - Step 5\"\n           style=\"width:300px;\"\n      />\n      <span class=\"step-badge\">\n        5\n      </span>\n    </div>\n\n    <div style=\"position: relative;\">\n      <img \n           src=\"/images/graph/dfs-phases/phase5.jpg\" \n           alt=\"DFS - Undirected Graph  - Step 6\"\n           style=\"width:300px;\"\n      />\n      <span class=\"step-badge\">\n        6\n      </span>\n    </div>\n\n\n    <div style=\"position: relative;\">\n      <img \n           src=\"/images/graph/dfs-phases/phase6.jpg\" \n           alt=\"DFS - Undirected Graph  - Step 7\"\n           style=\"width:300px;\"\n      />\n      <span class=\"step-badge\">\n        7\n      </span>\n    </div>\n\n  </div>\n\n  <div class=\"article-paragraph\">\n    The above code represents a recursive approach. The computational complexity\n    is then as follows:\n  </div>\n\n  <div class=\"article-paragraph\">\n    <b>Time complexity: O(V + E)</b>, where V is the number of vertices and E is the number of edges in the graph.\n  </div>\n\n  <div class=\"article-paragraph\">\n    Space complexity: O(2V) = O(V), because an additional array of visited elements of size V and a stack for recursive calls to the DFS function are required. In the worst case, if the graph is a straight line or a long path, DFS recursion can go as deep as the number of vertices.\n  </div>\n\n  <div class=\"article-paragraph\">\n    To change the recursive approach to an iterative one, we need to use a stack data structure. The code then looks as follows:\n  </div>\n\n  <pre class=\"article-paragraph\">\nprocedure DFS(initialNode):\n    stack = {initialNode}\n    visited = {initialNode}\n\n    while stack is not empty:\n        node = stack.pop()\n\n        for each neighbour in neighbours(node):\n            if neighbour not in visited:\n                stack.add(neighbour)\n                visited.add(neighbour)\n  </pre>\n\n  <div class=\"article-paragraph\">\n    <b>Time complexity: O(V + E)</b>, where V is the number of vertices and E is the number of edges in the graph.\n  </div>\n\n  <div class=\"article-paragraph\">\n    <b>Space complexity: O(2V) = O(V)</b>, because an additional array of visited elements of size V is required, as well as a stack that will store a total of V vertices.\n  </div>','[{\"answers\": [\"Depth First Search\", \"Direct Flow System\", \"Data Flow Search\", \"Depth Flow Sequence\"], \"question\": \"What does DFS mean in graph theory?\", \"explanation\": \"DFS stands for Depth First Search – an algorithm for searching a graph in depth.\", \"correctAnswer\": 1}, {\"answers\": [\"Kolejka (Queue)\", \"Stos (Stack)\", \"Kopiec (Heap)\", \"Kolejka priorytetowa (Priority Queue)\"], \"question\": \"Jaka struktura danych jest używana do implementacji DFS w sposób iteracyjny?\", \"explanation\": \"DFS korzysta ze stosu w implementacji iteracyjnej, aby śledzić kolejne wierzchołki do odwiedzenia.\", \"correctAnswer\": 2}, {\"answers\": [\"O(V)\", \"O(E)\", \"O(V + E)\", \"O(V * E)\"], \"question\": \"Jaka jest złożoność czasowa DFS dla grafu z V wierzchołkami i E krawędziami?\", \"explanation\": \"DFS odwiedza każdy wierzchołek i każdą krawędź dokładnie raz, co daje złożoność O(V + E).\", \"correctAnswer\": 3}, {\"answers\": [\"Aby przechowywać wartości wierzchołków\", \"Aby uniknąć wielokrotnego odwiedzania tego samego wierzchołka\", \"Aby przyspieszyć działanie algorytmu\", \"Aby przechowywać najkrótszą ścieżkę\"], \"question\": \"Dlaczego w DFS potrzebna jest tablica odwiedzonych wierzchołków?\", \"explanation\": \"Zbiór lub tablica visited zapobiega odwiedzaniu tych samych wierzchołków wielokrotnie, co chroni przed nieskończoną pętlą w grafach z cyklami.\", \"correctAnswer\": 2}, {\"answers\": [\"Post-order\", \"Pre-order\", \"In-order\", \"Level-order\"], \"question\": \"Któremu sposobowi przechodzenia drzewa odpowiada DFS - jeśli najpierw dodaje wierzchołek do odwiedzonych, a dopiero potem przechodzi do pozostałych wierzchołków.\", \"explanation\": \"Podobny jest do przechodzenia grafu w trybie pre-order, gdzie najpierw odwiedzamy początkowy wierzchołek i schodzimy jak najgłębiej, zanim przejdziemy do kolejnych gałęzi.\", \"correctAnswer\": 2}]'),(2,'BFS','bfs','BFS','[]'),(3,'Dijkstra Algorithm - Shortest Path','dijkstra','Dijkstra','[]'),(4,'Eulerian Path/Cycle','eulerian-path-cycle','Eulerian Path/Cycle','[]'),(5,'Kosaraju Algorithm - Strongly Connected Components','kosaraju-scc','Kosaraju Algorithm - Strongly Connected Components','[]');
/*!40000 ALTER TABLE `articles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `problems`
--

DROP TABLE IF EXISTS `problems`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `problems` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `slug` varchar(255) NOT NULL,
  `params` json NOT NULL,
  `description` text NOT NULL,
  `code` text NOT NULL,
  `header` text NOT NULL,
  `driver` text NOT NULL,
  `testcases` tinytext NOT NULL,
  `all_testcases` mediumtext NOT NULL,
  `time_limit` int NOT NULL DEFAULT '2000',
  `difficulty` enum('Easy','Medium','Hard') NOT NULL DEFAULT 'Easy',
  PRIMARY KEY (`id`),
  UNIQUE KEY `slug` (`slug`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `problems`
--

LOCK TABLES `problems` WRITE;
/*!40000 ALTER TABLE `problems` DISABLE KEYS */;
INSERT INTO `problems` VALUES (1,'Two Sum','two-sum','[\"a\", \"b\"]','<p>&nbsp;</p>\n<p>\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n</p>\n<p>&nbsp;</p>\n<p>\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n</p>\n<p>&nbsp;</p>\n<p>\nYou can return the answer in any order.\n</p>\n<p>&nbsp;</p>\n    \n<div>\n        <strong>Example 1:</strong>\n\n        <pre style=\"white-space: pre-wrap;\">\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n        </pre>\n</div>\n\n<div>\n        <strong>Example 1:</strong>\n\n        <pre style=\"white-space: pre-wrap;\">\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n        </pre>\n</div>','def add(a: int, b: int):\n return a + b;','import heapq\nfrom collections import deque\n','import sys\nimport io\nimport json\n\ndef solution(a, b):\n    return a + b\n\ndef run_testcase(func, a, b):\n    old_stdout = sys.stdout\n    sys.stdout = buffer = io.StringIO()\n    try:\n        got = func(a, b)\n        printed = buffer.getvalue()\n    finally:\n        sys.stdout = old_stdout\n    return {\"args\": [a,b], \"got\": got, \"expected\": solution(a, b), \"printed\": printed}\n\ndef main():\n    t = json.loads(input())\n    for _ in range(t):\n        a = json.loads(input())\n        b = json.loads(input())\n        res = run_testcase(add, a, b)\n        if res[\"got\"] != res[\"expected\"]:\n            output = {\"status\": \"Wrong Answer\", \"testcase\": res}\n            print(json.dumps(output))\n            return\n    print(json.dumps({\"status\": \"Accepted\"}))\n\nif __name__ == \"__main__\":\n    main()','1\n0\n1\n1\n1\n2','1\n0\n1\n0\n1\n0',2000,'Medium'),(6,'Sum of All Nodes','sum-of-all-nodes','[\"nodes\", \"edges\"]','<p>\nGiven an array <code>nodes</code> of size <code>n</code> and array <code>edges</code>. <code>nodes[i]</code> is the value of vertex <code>i</code>. In <code>edges[i]</code> each element <code>[u, v]</code>  represents an undirected edge between vertex u and vertex v. Return sum of nodes of each component.\n</p>\n<p>&nbsp;</p>\n<div>\n        <strong>Example 1:</strong>\n\n<pre class=\"example-block\">\n<strong>Input:</strong> nodes = [1, 2, 3, 4, 5], edges = [[0,1],[0,2],[3,4]]\n\n<strong>Output:</strong> [6,6,6,9,9]\n\n<strong>Explanation:</strong> \nNodes 0,1,2 form a connected component: sum = 1+2+3 = 6\nNodes 3,4 form a connected component: sum = 4+5 = 9\nResult = [6,6,6,9,9]\n</pre>\n</div>\n<p>&nbsp;</p>\n<div>\n        <strong>Constraints:</strong>\n  <div class=\"constraints\">\n   <ul>\n     <li><code>1 <= n <= 10^5</code></li>\n     <li><code>0 <= len(edges) <= 2*10^5</code></li>\n     <li><code>1 <= nodes[i] <= 10^9</code></li>\n     <li><code>0 <= u, v < n</code></li>\n     <li><code>u != v</code></li>\n     <li>No duplicate edges</li>\n   </ul>\n  </div>\n</div>','def sum_of_all_nodes(nodes: List[int], edges: List[List[int]]) -> List[int]:\n  n = len(nodes)\n  graph = defaultdict(list)\n  for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n  visited = [False] * n\n  result = [0] * n\n\n  def dfs(node, component):\n      visited[node] = True\n      component.append(node)\n      for neighbor in graph[node]:\n          if not visited[neighbor]:\n              dfs(neighbor, component)\n\n  for i in range(n):\n      if not visited[i]:\n          component = []\n          dfs(i, component)\n          total = sum(nodes[x] for x in component)\n          for x in component:\n              result[x] = total\n\n  return result','import heapq\nfrom collections import deque, defaultdict\nfrom typing import List','import sys\nimport io\nimport json\nfrom typing import List\nfrom collections import defaultdict\n\ndef solution(nodes: List[int], edges: List[List[int]]) -> List[int]:\n    n = len(nodes)\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * n\n    result = [0] * n\n\n    def dfs(node, component):\n        visited[node] = True\n        component.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, component)\n\n    for i in range(n):\n        if not visited[i]:\n            component = []\n            dfs(i, component)\n            total = sum(nodes[x] for x in component)\n            for x in component:\n                result[x] = total\n\n    return result\n\ndef run_testcase(func, a, b):\n    old_stdout = sys.stdout\n    sys.stdout = buffer = io.StringIO()\n    try:\n        got = func(a, b)\n        printed = buffer.getvalue()\n    finally:\n        sys.stdout = old_stdout\n    return {\"args\": [a,b], \"got\": got, \"expected\": solution(a, b), \"printed\": printed}\n\ndef main():\n    t = json.loads(input())\n    for _ in range(t):\n        a = json.loads(input())\n        b = json.loads(input())\n        res = run_testcase(sum_of_all_nodes, a, b)\n        if res[\"got\"] != res[\"expected\"]:\n            output = {\"status\": \"Wrong Answer\", \"testcase\": res}\n            print(json.dumps(output))\n            return\n    print(json.dumps({\"status\": \"Accepted\"}))\n\nif __name__ == \"__main__\":\n    main()','[1,2,3,4,5]\n[[0,1],[0,2],[3,4]]','[1,2,3,4,5]\n[[0,1],[0,2],[3,4]]\n[1,2]\n[[0,1]]',2000,'Easy');
/*!40000 ALTER TABLE `problems` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `visualizations`
--

DROP TABLE IF EXISTS `visualizations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `visualizations` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(200) NOT NULL,
  `slug` varchar(200) NOT NULL,
  `code` text NOT NULL,
  `initial_step` json NOT NULL,
  `pseudocode` varchar(2000) NOT NULL,
  `nodes` json NOT NULL,
  `edges` json NOT NULL,
  `reset_code` text NOT NULL,
  `is_node_selection_enabled` bit(1) NOT NULL DEFAULT b'1',
  `guide_text` varchar(3000) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `slug_UNIQUE` (`slug`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `visualizations`
--

LOCK TABLES `visualizations` WRITE;
/*!40000 ALTER TABLE `visualizations` DISABLE KEYS */;
INSERT INTO `visualizations` VALUES (1,'Euler Path - Undirected Graph','euler-path-undirected','async function algorithm({\n  graphRef,\n  tutorialRef,\n  waitOnClick,\n  nodes,\n  edges,\n  adjacency,\n  selectedNode,\n}) {\n  \n  visitedEdges = {}\n\n  async function eulerianPath(node, path = []) {\n    const neighbours = adjacency[node];\n\n    for (const neighbor of neighbours) {\n      if (!visitedEdges[node]) visitedEdges[node] = {};\n      if (!visitedEdges[neighbor.nodeId]) visitedEdges[neighbor.nodeId] = {};\n\n      if (visitedEdges[node][neighbor.nodeId]) continue;\n\n      visitedEdges[node][neighbor.nodeId] = true;\n      visitedEdges[neighbor.nodeId][node] = true;\n\n      graphRef.current?.markEdge({\n        sourceId: node,\n        destinationId: neighbor?.nodeId ?? \"\",\n      });\n      tutorialRef.current?.addTutorialStep({\n        description: `Usuwamy krawędź ${node}--${neighbor?.nodeId}`,\n        edge: { sourceId: node, destinationId: neighbor?.nodeId ?? \"\" },\n        variables: {\n          path: [...path],\n          neighbours: neighbours.map((neighbour) => neighbour.nodeId),\n          node: node,\n        },\n      });\n\n      await waitOnClick();\n\n      await eulerianPath(neighbor?.nodeId ?? \"\", path);\n    }\n\n    path.push(node);\n    graphRef.current?.markNode({ nodeId: node });\n    tutorialRef.current?.addTutorialStep({\n      description: `Dodajemy wierzchołek ${node} do path`,\n      node: { nodeId: node },\n      variables: {\n        path: [...path],\n        neighbours: neighbours.map((neighbour) => neighbour.nodeId),\n        node: node,\n      },\n    });\n\n    await waitOnClick();\n  }\n\n  await eulerianPath(selectedNode);\n}\n\nreturn algorithm;','{\"variables\": {\"node\": \"\", \"path\": [], \"neighbours\": []}, \"buttonText\": \"Start\", \"description\": \"Ścieżka i cykl Eulera polegają na przejściu przez wszystkie krawędzie grafu dokładnie raz. Ścieżka zaczyna się w jednym wierzchołku i kończy w innym, cykl zaczyna się i kończy w tym samym wierzchołku.\"}','procedure EulerPath(V)\n    for each edge (V, U) in Graph:\n        remove edge (V, U) from Graph\n        remove edge (U, V) from Graph\n        EulerPath(U)\n    add V to path','[{\"id\": \"1\"}, {\"id\": \"2\"}, {\"id\": \"3\"}, {\"id\": \"4\"}, {\"id\": \"5\"}, {\"id\": \"6\"}]','[{\"source\": {\"id\": \"1\"}, \"target\": {\"id\": \"3\"}}, {\"source\": {\"id\": \"3\"}, \"target\": {\"id\": \"5\"}}, {\"source\": {\"id\": \"5\"}, \"target\": {\"id\": \"6\"}}, {\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"1\"}}, {\"source\": {\"id\": \"6\"}, \"target\": {\"id\": \"4\"}}, {\"source\": {\"id\": \"4\"}, \"target\": {\"id\": \"2\"}}]','function reset({graphRef, tutorialRef}) {\n      \n}\n\nreturn reset',_binary '','W algorytmie znajdowania ścieżki Eulera kluczowe jest rozpoczęcie z odpowiedniego wierzchołka. W przypadku grafu nieskierowanego:\n<ul style=\"list-style-type: disc; padding-left: 1em;\">\n  <li style=\"margin: 1em 0;\">\n  jeśli wszystkie wierzchołki mają parzystą liczbę krawędzi, algorytm może rozpocząć się z dowolnego wierzchołka\n  </li>\n  <li style=\"margin: 1em 0;\">\n  jeśli istnieją dokładnie dwa wierzchołki o nieparzystej liczbie krawędzi, algorytm powinien rozpocząć się z jednego z tych wierzchołków.\n  </li>\n</ul>'),(2,'Euler Path - Directed Graph','euler-path-directed','async function algorithm({\n  graphRef,\n  tutorialRef,\n  waitOnClick,\n  nodes,\n  edges,\n  adjacency,\n  selectedNode,\n}) {\n  async function eulerianPath(node, path = []) {\n    const neighbours = adjacency[node];\n\n    while (neighbours.length) {\n      const neighbor = neighbours.pop();\n\n      graphRef.current?.markEdge({\n        sourceId: node,\n        destinationId: neighbor?.nodeId ?? \"\",\n      });\n      tutorialRef.current?.addTutorialStep({\n        description: `Usuwamy krawędź ${node}--${neighbor?.nodeId}`,\n        edge: { sourceId: node, destinationId: neighbor?.nodeId ?? \"\" },\n        variables: {\n          path: [...path],\n          neighbours: neighbours.map((neighbour) => neighbour.nodeId),\n          node: node,\n        },\n      });\n      await waitOnClick();\n\n      await eulerianPath(neighbor?.nodeId ?? \"\", path);\n    }\n\n    path.push(node);\n    graphRef.current?.markNode({ nodeId: node });\n    tutorialRef.current?.addTutorialStep({\n      description: `Dodajemy wierzchołek ${node} do path`,\n      node: { nodeId: node },\n      variables: {\n        path: [...path],\n        neighbours: neighbours.map((neighbour) => neighbour.nodeId),\n        node: node,\n      },\n    });\n\n    await waitOnClick();\n  }\n\n  await eulerianPath(selectedNode);\n}\n\nreturn algorithm;','{\"variables\": {\"node\": \"\", \"path\": [], \"neighbours\": []}, \"buttonText\": \"Start\", \"description\": \"Ścieżka i cykl Eulera polegają na przejściu przez wszystkie krawędzie grafu dokładnie raz. Ścieżka zaczyna się w jednym wierzchołku i kończy w innym, cykl zaczyna się i kończy w tym samym wierzchołku.\"}','procedure EulerPath(V)\n    for each edge (V, U) in Graph:\n        remove edge (V, U) from Graph\n        EulerPath(U)\n    add V to path','[{\"id\": \"1\"}, {\"id\": \"2\"}, {\"id\": \"3\"}, {\"id\": \"4\"}, {\"id\": \"5\"}, {\"id\": \"6\"}]','[{\"source\": {\"id\": \"1\"}, \"target\": {\"id\": \"3\"}, \"directed\": true}, {\"source\": {\"id\": \"3\"}, \"target\": {\"id\": \"5\"}, \"directed\": true}, {\"source\": {\"id\": \"5\"}, \"target\": {\"id\": \"6\"}, \"directed\": true}, {\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"1\"}, \"directed\": true}, {\"source\": {\"id\": \"6\"}, \"target\": {\"id\": \"4\"}, \"directed\": true}, {\"source\": {\"id\": \"4\"}, \"target\": {\"id\": \"2\"}, \"directed\": true}]','function reset({graphRef, tutorialRef}) {\n      \n}\n\nreturn reset',_binary '','W algorytmie znajdowania ścieżki Eulera kluczowe jest rozpoczęcie z odpowiedniego wierzchołka. W przypadku grafu skierowanego:\n<ul style=\"list-style-type: disc; padding-left: 1em;\">\n  <li style=\"margin: 1em 0;\">\n    jeśli dokładnie jeden wierzchołek ma o jedną krawędź więcej\n    wychodzącą niż wchodzącą (to będzie początek ścieżki), dokładnie\n    jeden wierzchołek ma o jedną krawędź więcej wchodzącą niż wychodzącą\n    (to będzie koniec ścieżki) i wszystkie pozostałe wierzchołki mają\n    równą liczbę krawędzi wchodzących i wychodzących.\n  </li>\n  <li style=\"margin: 1em 0;\">\n    jeśli wszystkie wierzchołki mają równą liczbę krawędzi wchodzących i\n    wychodzących, algorytm może rozpocząć się z dowolnego wierzchołka\n  </li>\n</ul>'),(3,'Kosaraju Algorithm - Strongly Connected Components','kosaraju-scc','async function algorithm({\n  graphRef,\n  tutorialRef,\n  waitOnClick,\n  nodes,\n  edges,\n  adjacency,\n  selectedNode,\n}) {\n\n  for (const [source, neighbours] of Object.entries(adjacency)) {\n    adjacency[source] = neighbours.map((val) => val.nodeId);\n  }\n\n  let visited = {};\n  const order = [];\n  const components = [];\n\n  async function dfs1(v, graph, order) {\n    visited[v] = true;\n\n    graphRef.current?.markNode({ nodeId: v });\n    tutorialRef.current?.addTutorialStep({\n      description: `Odwiedzamy wierzchołek ${v}`,\n      variables: {\n        node: v,\n        neighbours: [...graph[v]],\n        order: [...order],\n      },\n      node: { nodeId: v },\n    });\n    await waitOnClick();\n\n    for (const u of graph[v]) {\n      if (!visited[u]) {\n        graphRef.current?.markEdge({\n          sourceId: v,\n          destinationId: u,\n          directed: true,\n        });\n        tutorialRef.current?.addTutorialStep({\n          description: `Krawędź ${v}->${u}: przechodzimy do sąsiedniego wierzchołka.`,\n          variables: {\n            node: v,\n            neighbours: [...graph[v]],\n            order: [...order],\n          },\n          edge: { sourceId: v, destinationId: u, directed: true },\n        });\n        await waitOnClick();\n\n        await dfs1(u, graph, order);\n      }\n    }\n\n    order.push(v);\n\n    tutorialRef.current?.addTutorialStep({\n      description: `Dodajemy wierzchołek ${v} do tablicy order`,\n      variables: {\n        node: v,\n        neighbours: [...graph[v]],\n        order: [...order],\n      },\n    });\n    await waitOnClick();\n  }\n\n  async function dfs2(v, graph, component) {\n    visited[v] = true;\n\n    graphRef.current?.markNode({ nodeId: v });\n    tutorialRef.current?.addTutorialStep({\n      description: `Odwiedzamy wierzchołek ${v}`,\n      variables: {\n        node: v,\n        neighbours: [...graph[v]],\n        order: [...order],\n        component: [...component],\n        components: _.cloneDeep(components),\n      },\n      node: { nodeId: v },\n    });\n    await waitOnClick();\n\n    for (const u of graph[v]) {\n      if (!visited[u]) {\n        graphRef.current?.markEdge({\n          sourceId: v,\n          destinationId: u,\n          directed: true,\n        });\n        tutorialRef.current?.addTutorialStep({\n          description: `Krawędź ${v}->${u}: przechodzimy do sąsiedniego wierzchołka.`,\n          variables: {\n            node: v,\n            neighbours: [...graph[v]],\n            order: [...order],\n            component: [...component],\n            components: _.cloneDeep(components),\n          },\n          edge: { sourceId: v, destinationId: u, directed: true },\n        });\n        await waitOnClick();\n\n        await dfs2(u, graph, component);\n      }\n    }\n\n    component.push(v);\n\n    tutorialRef.current?.addTutorialStep({\n      description: `Dodajemy wierzchołek ${v} do tablicy component`,\n      variables: {\n        node: v,\n        neighbours: [...graph[v]],\n        order: [...order],\n        component: [...component],\n        components: _.cloneDeep(components),\n      },\n    });\n    await waitOnClick();\n  }\n\n  for (const node of nodes) {\n    if (!visited[node.id]) await dfs1(node.id, adjacency, order);\n  }\n\n  const adj_rev = {};\n\n  for (const node of nodes) {\n    adj_rev[node.id] = [];\n  }\n\n  for (const v of nodes) {\n    for (const u of adjacency[v.id]) {\n      adj_rev[u].push(v.id);\n    }\n  }\n\n  tutorialRef.current?.addTutorialStep({\n    description: `Z grafu początkowego uzyskujemy graf transponowany, w którym wszystkie krawędzie mają odwrócony kierunek.`,\n    transpose: true,\n    prevMarkings: graphRef.current?.getMarkings(),\n    nextMarkings: graphRef.current?.getDefaultMarkings(),\n  });\n  graphRef.current?.resetMarks();\n  graphRef.current?.transpose();\n\n  await waitOnClick();\n\n  visited = {};\n\n  while (order.length) {\n    const v = order.pop() ?? \"\";\n\n    tutorialRef.current?.addTutorialStep({\n      description: `Usuwamy ostatni element z tablicy order i jeśli nie został jeszcze odwiedzony to wykonujemy dfs2(${v})`,\n      variables: {\n        node: v,\n        neighbours: [...adj_rev[v]],\n        order: [...order],\n        component: [],\n        components: _.cloneDeep(components),\n      },\n    });\n    await waitOnClick();\n\n    if (!visited[v]) {\n      const component = [];\n      await dfs2(v, adj_rev, component);\n      components.push(component);\n\n      tutorialRef.current?.addTutorialStep({\n        description: `Algorytm znalazł komponent (${component.join(\",\")})`,\n        variables: {\n          node: v,\n          neighbours: [...adj_rev[v]],\n          order: [...order],\n          component: [...component],\n          components: _.cloneDeep(components),\n        },\n      });\n      await waitOnClick();\n    }\n  }\n}\n\nreturn algorithm;\n','{\"variables\": {\"node\": \"\", \"order\": [], \"components\": [], \"neighbours\": []}, \"buttonText\": \"Start\", \"description\": \"Kosaraju polega na dwukrotnym przeszukaniu grafu w głąb - najpierw wykonujemy DFS, zapisując wierzchołki w kolejności ich zakończenia, a następnie odwracamy krawędzie i ponownie wykonujemy DFS w odwrotnej kolejności, aby znaleźć grupy wierzchołków wzajemnie osiągalnych.\"}','procedure Kosaraju(G):\n    S = empty stack\n    visited = empty set\n\n    # Step 1: DFS on original graph to fill stack\n    for each node in G:\n        if node not in visited:\n            DFS1(node)\n\n    # Step 2: Transpose the graph\n    GT = transpose(G)\n\n    # Step 3: DFS on transposed graph in stack order\n    visited = empty set\n    SCCs = empty list\n\n    while S not empty:\n        node = S.pop()\n        if node not in visited:\n            component = empty list\n            DFS2(node, component)\n            SCCs.append(component)\n\n    return SCCs\n\n\nprocedure DFS1(node):\n    visited.add(node)\n    for each neighbour in neighbours(node):\n        if neighbour not in visited:\n            DFS1(neighbour)\n    S.push(node)\n\n\nprocedure DFS2(node, component):\n    visited.add(node)\n    component.append(node)\n    for each neighbour in neighbours(node, in GT):\n        if neighbour not in visited:\n            DFS2(neighbour, component)\n\n\nfunction transpose(G):\n    GT = new graph\n    for each (u, v) in G.edges:\n        add edge (v, u) to GT\n    return GT','[{\"id\": \"1\"}, {\"id\": \"2\"}, {\"id\": \"3\"}, {\"id\": \"4\"}, {\"id\": \"5\"}, {\"id\": \"6\"}]','[{\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"1\"}, \"directed\": true}, {\"source\": {\"id\": \"1\"}, \"target\": {\"id\": \"3\"}, \"directed\": true}, {\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"4\"}, \"directed\": true}, {\"source\": {\"id\": \"3\"}, \"target\": {\"id\": \"5\"}, \"directed\": true}, {\"source\": {\"id\": \"5\"}, \"target\": {\"id\": \"6\"}, \"directed\": true}, {\"source\": {\"id\": \"5\"}, \"target\": {\"id\": \"2\"}, \"directed\": true}]','function reset({graphRef, tutorialRef}) {\n    graphRef.current?.transpose()\n}\n\nreturn reset',_binary '\0',''),(4,'Dijkstra Algorithm - Shortest Path','dijkstra','async function algorithm({\n  graphRef,\n  tutorialRef,\n  waitOnClick,\n  nodes,\n  edges,\n  adjacency,\n  selectedNode\n}) {\n  const toNumber = (str) => (isNaN(Number(str)) ? 0 : Number(str));\n\n  async function dijkstra(node) {\n    const minQ = new this.MinPriorityQueue((item) => toNumber(item.weight));\n    const visited = new Set();\n\n    minQ.enqueue({ nodeId: node, weight: \"0\" });\n\n    tutorialRef.current?.addTutorialStep({\n      description: `Dodajemy wierzchołek ${node} do kolejki priorytetowej jako punkt startowy algorytmu Dijkstry. To od niego rozpoczynamy wyznaczanie najkrótszych ścieżek do pozostałych wierzchołków grafu.`,\n      node: { nodeId: node },\n      variables: {\n        queue: minQ.toArray(),\n        visited: Array.from(visited),\n        neighbours: adjacency[node].map((node) => node.nodeId),\n        node,\n      },\n    });\n    await waitOnClick();\n\n    while (!minQ.isEmpty()) {\n      const minNode = minQ.dequeue();\n\n      if (!minNode) continue;\n\n      if (visited.has(minNode.nodeId)) {\n        tutorialRef.current?.addTutorialStep({\n          description: `Usuwamy z kolejki wierzchołek ${minNode.nodeId}, jednak został on już wcześniej odwiedzony. Pomijamy go, aby uniknąć ponownego przetwarzania i zachować poprawność działania algorytmu Dijkstry.`,\n          variables: {\n            queue: minQ.toArray(),\n            visited: Array.from(visited),\n            neighbours: adjacency[minNode.nodeId].map((node) => node.nodeId),\n            node: minNode.nodeId,\n          },\n        });\n\n        await waitOnClick();\n\n        continue;\n      }\n\n      visited.add(minNode.nodeId);\n      graphRef.current?.markNode({ nodeId: minNode.nodeId });\n\n      tutorialRef.current?.addTutorialStep({\n        description: `Usuwamy z kolejki priorytetowej wierzchołek o najmniejszej wadze ścieżki prowadzącej do niego z wierzchołka początkowego ${node}. W tym kroku usuwamy wierzchołek ${minNode.nodeId} o łącznej wadze ścieżki równej ${minNode.weight}.`,\n        node: { nodeId: minNode.nodeId },\n        variables: {\n          queue: minQ.toArray(),\n          visited: Array.from(visited),\n          neighbours: adjacency[minNode.nodeId].map((node) => node.nodeId),\n          node: minNode.nodeId,\n        },\n      });\n\n      await waitOnClick();\n\n      for (const nextNode of adjacency[minNode.nodeId]) {\n        if (visited.has(nextNode.nodeId)) {\n          tutorialRef.current?.addTutorialStep({\n            description: `Krawędź ${minNode.nodeId} -- ${nextNode.nodeId}: Wierzchołek ${nextNode.nodeId} został już wcześniej odwiedzony. Pomijamy tę krawędź, aby uniknąć ponownego przetwarzania i zapewnić poprawność działania algorytmu Dijkstry.`,\n            variables: {\n              queue: minQ.toArray(),\n              visited: Array.from(visited),\n              neighbours: adjacency[minNode.nodeId].map((node) => node.nodeId),\n              node: minNode.nodeId,\n            },\n          });\n\n          await waitOnClick();\n\n          continue;\n        }\n\n        minQ.enqueue({\n          nodeId: nextNode.nodeId,\n          weight: (\n            toNumber(nextNode.weight) + toNumber(minNode.weight)\n          ).toString(),\n        });\n\n        graphRef.current?.markEdge({\n          sourceId: minNode.nodeId,\n          destinationId: nextNode.nodeId,\n          directed: true,\n        });\n        tutorialRef.current?.addTutorialStep({\n          description: `Krawędź ${minNode.nodeId} -- ${nextNode.nodeId}: Wierzchołek ${nextNode.nodeId} zostaje umieszczony w kolejce priorytetowej typu min z wartością priorytetu równą sumie dotychczasowego dystansu do ${minNode.nodeId} oraz wagi tej krawędzi.`,\n          variables: {\n            queue: minQ.toArray(),\n            visited: Array.from(visited),\n            neighbours: adjacency[minNode.nodeId].map((node) => node.nodeId),\n            node: minNode.nodeId,\n          },\n          edge: {\n            sourceId: minNode.nodeId,\n            destinationId: nextNode.nodeId,\n            directed: true,\n          },\n        });\n\n        await waitOnClick();\n      }\n    }\n  }\n\n  await dijkstra.bind(this)(selectedNode);\n}\n\nreturn algorithm;','{\"variables\": {\"node\": \"\", \"queue\": [], \"visited\": [], \"neighbours\": []}, \"buttonText\": \"Start\", \"description\": \"Dijkstra polega na znajdowaniu najkrótszej ścieżki od jednego wierzchołka do wszystkich pozostałych w grafie z dodatnimi wagami krawędzi. Zaczynamy od wierzchołka startowego i stopniowo odwiedzamy te wierzchołki, do których droga jest obecnie najkrótsza. Dla każdego z nich aktualizujemy odległości do sąsiadów, aż znajdziemy najkrótsze trasy do wszystkich punktów.\"}','procedure Dijkstra(startNode):\n  for each vertex v in Graph:\n    distance[v] <- ∞\n    previous[v] <- undefined\n  distance[startNode] <- 0\n\n  priorityQueue <- empty min-priority queue\n  priorityQueue.insert(startNode, 0)\n\n  while priorityQueue is not empty:\n    node <- priorityQueue.extractMin()\n\n    if node is already visited:\n      continue\n\n    mark node as visited\n\n    for each neighbour in neighbours(node):\n      newDistance <- distance[node] + weight(node, neighbour)\n      if newDistance < distance[neighbour]:\n        distance[neighbour] <- newDistance\n        previous[neighbour] <- node\n        priorityQueue.insert(neighbour, newDistance)','[{\"id\": \"1\"}, {\"id\": \"2\"}, {\"id\": \"3\"}, {\"id\": \"4\"}, {\"id\": \"5\"}, {\"id\": \"6\"}]','[{\"source\": {\"id\": \"1\"}, \"target\": {\"id\": \"2\"}, \"weight\": \"6\", \"directed\": true}, {\"source\": {\"id\": \"1\"}, \"target\": {\"id\": \"3\"}, \"weight\": \"3\", \"directed\": true}, {\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"4\"}, \"weight\": \"1\", \"directed\": true}, {\"source\": {\"id\": \"3\"}, \"target\": {\"id\": \"5\"}, \"weight\": \"8\", \"directed\": true}, {\"source\": {\"id\": \"5\"}, \"target\": {\"id\": \"6\"}, \"weight\": \"5\", \"directed\": true}, {\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"5\"}, \"weight\": \"2\", \"directed\": true}]','function reset({graphRef, tutorialRef}) {\n\n}\n\nreturn reset',_binary '',''),(5,'DFS','dfs','async function algorithm(\n{\n	graphRef,\n	tutorialRef,\n	waitOnClick,\n  	nodes,\n  	edges,\n	adjacency,\n  	selectedNode\n}\n) {\n\n  for (const [source, neighbours] of Object.entries(adjacency)) {\n    adjacency[source] = neighbours.map((val) => val.nodeId);\n  }\n\n  const visitedEdges = {};\n\n  for (const node of nodes) {\n    visitedEdges[node.id] = {};\n  }\n  \n  async function dfs(node, visited = new Set()) {\n    visited.add(node);\n\n    graphRef.current?.markNode({ nodeId: node });\n\n    if (visited.size === 1)\n      tutorialRef.current?.addTutorialStep({\n        description: `Zaczynamy od Node ${node}`,\n        node: { nodeId: node },\n        variables: {\n          visited: Array.from(visited),\n          neighbours: adjacency[node],\n          node,\n        },\n      });\n    else\n      tutorialRef.current?.addTutorialStep({\n        description: `Odwiedzamy Node ${node}`,\n        node: { nodeId: node },\n        variables: {\n          visited: Array.from(visited),\n          neighbours: adjacency[node],\n          node,\n        },\n      });\n\n    await waitOnClick();\n\n    for (const neighbor of adjacency[node]) {\n      if (visited.has(neighbor)) {\n        if (\n          !visitedEdges[node][neighbor] &&\n          !visitedEdges[neighbor][node]\n        ) {\n          graphRef.current?.markEdge({\n            sourceId: node,\n            destinationId: neighbor,\n            directed: false,\n            edgeColor: \"gray\",\n          });\n\n          tutorialRef.current?.addTutorialStep({\n            description: `Krawędź ${node} -- ${neighbor}: Wierzchołek ${neighbor} był już odwiedzony, ale nie przez tę krawędź. Oznaczamy ją szaro, aby zaznaczyć, że została sprawdzona.`,\n            variables: {\n              visited: Array.from(visited),\n              neighbours: adjacency[node],\n              node,\n            },\n            edge: {\n              sourceId: node,\n              destinationId: neighbor,\n              directed: false,\n              edgeColor: \"gray\",\n            },\n          });\n\n          await waitOnClick();\n        } else {\n          tutorialRef.current?.addTutorialStep({\n            description: `Krawędź ${node} -- ${neighbor}: Wierzchołek ${neighbor} został już odwiedzony tą krawędzią. Pomijamy ją, aby uniknąć powtórzeń.`,\n            variables: {\n              visited: Array.from(visited),\n              neighbours: adjacency[node],\n              node,\n            },\n          });\n\n          await waitOnClick();\n        }\n        continue;\n      }\n\n      tutorialRef.current?.addTutorialStep({\n        description: `Krawędź ${node} -- ${neighbor}: Przechodzimy do wierzchołka ${neighbor}, ponieważ nie był jeszcze odwiedzony. Jest to krawędź drzewa DFS.`,\n        variables: {\n          visited: Array.from(visited),\n          neighbours: adjacency[node],\n          node,\n        },\n      });\n\n      await waitOnClick();\n\n      visitedEdges[node][neighbor] = true;\n      visitedEdges[neighbor][node] = true;\n\n      graphRef.current?.markEdge({\n        sourceId: node,\n        destinationId: neighbor,\n        directed: false,\n      });\n      tutorialRef.current?.addTutorialStep({\n        edge: { sourceId: node, destinationId: neighbor, directed: false },\n        isStep: false,\n      });\n\n      await dfs(neighbor, visited);\n    }\n\n    tutorialRef.current?.addTutorialStep({\n      description: `Brak kolejnych nieodwiedzonych sąsiadów dlatego wracamy z wierzchołka ${node} do poprzednika.`,\n      variables: {\n        visited: Array.from(visited),\n        neighbours: adjacency[node],\n        node,\n      },\n    });\n\n    await waitOnClick();\n  }\n\n  await dfs(selectedNode)\n}\n\nreturn algorithm','{\"variables\": {\"node\": \"\", \"visited\": [], \"neighbours\": []}, \"buttonText\": \"Start\", \"description\": \"DFS polega na eksploracji grafu najpierw w głąb. Wybieramy dowolny wierzchołek i z niego idziemy do kolejnych w obojętnej kolejności, ale nie możemy odwiedzic tego samego wierzchołka dwa razy.\"}','procedure DFS(node):\n  visited.add(node)\n  for each neighbour in neighbours(node):\n    if neighbour not in visited:\n      DFS(neighbour)','[{\"id\": \"1\"}, {\"id\": \"2\"}, {\"id\": \"3\"}, {\"id\": \"4\"}, {\"id\": \"5\"}, {\"id\": \"6\"}]','[{\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"1\"}}, {\"source\": {\"id\": \"1\"}, \"target\": {\"id\": \"3\"}}, {\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"4\"}}, {\"source\": {\"id\": \"3\"}, \"target\": {\"id\": \"5\"}}, {\"source\": {\"id\": \"5\"}, \"target\": {\"id\": \"6\"}}, {\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"5\"}}]','function reset({graphRef, tutorialRef}) {\n\n}\n\nreturn reset',_binary '',''),(6,'BFS','bfs','async function algorithm(\n{\n	graphRef,\n	tutorialRef,\n	waitOnClick,\n  	nodes,\n  	edges,\n	adjacency,\n  	selectedNode\n}\n) {  \n\n  for (const [source, neighbours] of Object.entries(adjacency)) {\n    adjacency[source] = neighbours.map((val) => val.nodeId);\n  }\n\n  async function bfs(startId, visited = new Set()) {\n      const queue = [startId];\n      visited.add(startId);\n\n      const prevNodes = {};\n\n      tutorialRef.current?.addTutorialStep({\n        description: `Dodajemy wierzchołek ${startId} do kolejki jako wierzchołek początkowy`,\n        variables: {\n          queue: Array.from(queue),\n          node: startId,\n        },\n      });\n\n      await waitOnClick();\n\n      while (queue.length > 0) {\n        const node = queue.shift() ?? \"\";\n\n        graphRef.current?.markNode({ nodeId: node });\n\n        const prevNode = prevNodes[node];\n\n        if (prevNode) {\n          graphRef.current?.markEdge({\n            sourceId: prevNode,\n            destinationId: node,\n          });\n        }\n\n        tutorialRef.current?.addTutorialStep({\n          description: `Usuwamy pierwszy wierzchołek z kolejki i odwiedzamy (wierzchołek ${node})`,\n          node: { nodeId: node },\n          variables: {\n            queue: Array.from(queue),\n            node,\n          },\n          edge: prevNode\n            ? { sourceId: prevNode, destinationId: node }\n            : undefined,\n        });\n\n        await waitOnClick();\n\n        const addedNeighbours = [];\n\n        for (const neighbor of adjacency[node]) {\n          if (!visited.has(neighbor)) {\n            visited.add(neighbor);\n            queue.push(neighbor);\n            prevNodes[neighbor] = node;\n\n            addedNeighbours.push(neighbor);\n          }\n        }\n\n        if (addedNeighbours.length) {\n          tutorialRef.current?.addTutorialStep({\n            description: `Dodajemy do kolejki nieodwiedzonych wcześniej sąsiadów wierzchołka ${node} -> (${addedNeighbours})`,\n            variables: {\n              queue: Array.from(queue),\n              node,\n            },\n          });\n\n          await waitOnClick();\n        }\n      }\n\n      tutorialRef.current?.addTutorialStep({\n        description: `Wszystkie wierzchołki zostały odwiedzone.`,\n        buttonText: \"Restart\",\n      });\n\n      const buttonClickHandler = () => {\n        tutorialRef.current?.resetTutorialSteps();\n        graphRef.current?.resetMarks();\n\n        tutorialRef.current?.addTutorialStep(initialStep);\n\n        const nextButtonClickHandler = () => {\n          bfs(initialNode);\n        };\n\n        tutorialRef.current?.setNextButtonOnceClickHanlder(\n          nextButtonClickHandler,\n        );\n      };\n\n      tutorialRef.current?.setNextButtonOnceClickHanlder(buttonClickHandler);\n    }\n  \n    await bfs(selectedNode)\n}\n\nreturn algorithm','{\"variables\": {\"node\": \"\", \"queue\": []}, \"buttonText\": \"Start\", \"description\": \"BFS polega na eksploracji grafu warstawi. Wybieramy dowolny wierzchołek i z niego idziemy do sąsiadów, ale nie możemy odwiedzic tego samego wierzchołka dwa razy.\"}','procedure BFS(start):\n  visited <- new Set()\n  queue <- new Queue()\n\n  queue.enqueue(start)\n  visited.add(start)\n\n  while not queue.isEmpty():\n    node <- queue.dequeue()\n\n    for each neighbour in neighbours(node):\n      if neighbour not in visited:\n        visited.add(neighbour)\n        queue.enqueue(neighbour)','[{\"id\": \"1\"}, {\"id\": \"2\"}, {\"id\": \"3\"}, {\"id\": \"4\"}, {\"id\": \"5\"}, {\"id\": \"6\"}]','[{\"source\": {\"id\": \"1\"}, \"target\": {\"id\": \"2\"}}, {\"source\": {\"id\": \"1\"}, \"target\": {\"id\": \"3\"}}, {\"source\": {\"id\": \"2\"}, \"target\": {\"id\": \"4\"}}, {\"source\": {\"id\": \"3\"}, \"target\": {\"id\": \"5\"}}, {\"source\": {\"id\": \"5\"}, \"target\": {\"id\": \"6\"}}]','function reset({graphRef, tutorialRef}) {\n\n}\n\nreturn reset',_binary '','');
/*!40000 ALTER TABLE `visualizations` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2026-01-09 19:17:37
